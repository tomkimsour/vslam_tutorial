extern crate nalgebra as na;
use std::{time::{Instant, Duration}, thread::sleep};

use na::{Matrix2x3,Vector3, DMatrix, Matrix3, SMatrix};
use na::linalg::{ColPivQR,Cholesky};

pub fn nalgebra_matrix(){
    // First declare a static matrix and initialize it with zeros
    let mut matrix = Matrix2x3::<f32>::zeros();
    print!("{:}",matrix);

    // Then initialize a vector 
    let vector = Vector3::<f32>::zeros();
    print!("{:}",vector);

    // // it is also possible to use dynamic matrix if you are not sure about the size.
    let dmatrix = DMatrix::from_vec(2,2,vec![2.2,3.2,1.5,6.5]);
    println!("{:}",dmatrix);

    matrix = Matrix2x3::from_row_slice(&[
        1.2, 1.1, 1.2,
        3.1, 2.5, 1.5
    ]);
    
    print!("{:}",matrix);

    let dmatrix = DMatrix::from_vec(3,2,vec![5.5,6.3,2.2,3.2,1.5,6.5]);
    println!("{:}",matrix*dmatrix);

    // Let s give a look at all the operations possible
    let matrix_33 = Matrix3::<f32>::new_random();
    println!("{:}",matrix_33);
    println!("transpose : {:}",matrix_33.transpose());
    println!("sum : {:}",matrix_33.sum());
    println!("trace : {:}",matrix_33.trace());
    println!("times 10 : {:}", matrix_33.scale(10.0));
    println!("inverse : {:}", matrix_33.try_inverse().unwrap());
    println!("determinant : {:}", matrix_33.determinant());

    // Computes eigen values
    let symetric_m33= matrix_33.transpose() * matrix_33;
    let eigen_solver = symetric_m33.symmetric_eigen();
    println!("Eigen values : {:}", eigen_solver.eigenvalues);
    println!("Eigen vectors : {:}", eigen_solver.eigenvectors);

    // Solving equations
    // We solve the equation of matrix_NN âˆ— x = v_Nd
    // The size of N is defined in the previous macro, which is generated by a
    // random number Direct inversion is the most direct, but the amount of
    // inverse operations is large.

    let static_matrix : SMatrix<f32,50,50> = SMatrix::new_random();
    let symetric_m = static_matrix.transpose() * static_matrix;
    let v_Nd : SMatrix<f32,50,1> = SMatrix::new_random();

    let chrono = Instant::now();

    // Direct inversion
    let x = symetric_m.try_inverse().unwrap() * v_Nd;
    println!("{:?} s",chrono.elapsed());
    println!("x = {:}", x.transpose());

    // Usually solved by matrix decomposition, such as QR decomposition, the speed
    // will be much faster
    let chrono = Instant::now();
    let x = symetric_m.qr().solve(&v_Nd).unwrap();
    println!("{:?} s",chrono.elapsed());
    println!("x = {:}",x.transpose());

    // For positive definite matrices, you can also use cholesky decomposition to
    // solve equations.
    let chrono = Instant::now();
    let x = symetric_m.cholesky().unwrap().solve(&v_Nd);
    println!("{:?} s",chrono.elapsed());
    println!("x = {:}",x.transpose());
    println!("{:?} s",chrono.elapsed());

}